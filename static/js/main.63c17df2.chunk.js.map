{"version":3,"sources":["SortingVisualizer/sortingAlgorithms.js","SortingVisualizer/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["insertionSort","array","animations","i","length","unsortedElement","index","push","shellSort","space","Math","floor","barIndexArray","barIndex","last","j","mergeSort","auxArray","splice","mergeSortDivide","startIndex","endIndex","midIndex","mergeSortMerge","k","sortIsRunning","SortingVisualizer","props","state","this","resetArray","min","max","random","setState","arrayBars","document","getElementsByClassName","style","backgroundColor","resetColors","array1","array2","console","log","toString","className","class","map","element","id","key","height","Button","size","variant","onClick","selectionSort","tmp","sortingAlgorithms","animationType","barOneIndex","barTwoIndex","color","barOneStyle","barTwoStyle","setTimeout","SPEED_MS","barOneValue","barTwoValue","sortedBarIndex","otherBarIndex","defaultColor","sortedColor","sortedBarStyle","otherBarStyle","finalBarIndex","finalBarValue","finalBarStyle","bar","start","end","barValue","barStyle","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.63c17df2.chunk.js","sourcesContent":["var defaultColor = '#7f78d2';\r\nvar sortedColor = '#613885';\r\nvar compareColor = '#3fc5f0';\r\nvar secondCompareColor = '#83b87b';\r\n\r\n// SELECTION SORT\r\nexport const selectionSort = (array) => {   \r\n    var animations = [];\r\n\r\n    for (let i=0; i < array.length; i++) {\r\n        let min = i;\r\n\r\n        for (let j = i+1; j < array.length; j++) {\r\n            if (array[min] > array[j]) {\r\n                min = j;\r\n            }\r\n        }\r\n        // Turns on color for bars to be compared\r\n        animations.push([i, min, compareColor, 'COMPARING']);\r\n        // Swaps height (values) of bars\r\n        animations.push([i, array[i], min, array[min], 'SWAP_VALUES']); \r\n        // Resets bars back to default/sorted color\r\n        animations.push([i, min, defaultColor, sortedColor, 'SORTED']); \r\n\r\n        if (min !== i) {\r\n            let tmp = array[i];\r\n            array[i] = array[min];\r\n            array[min] = tmp;\r\n        }\r\n    }\r\n    return animations;\r\n}\r\n\r\n\r\n\r\n// INSERTION SORT\r\nexport const insertionSort = (array) => {\r\n    var animations = [];\r\n\r\n    for (let i=1; i < array.length; i++) {\r\n\r\n        let unsortedElement = array[i];\r\n        let index = i-1;\r\n\r\n        // Makes sure first index is colored sorted after each iteration\r\n        if (index === 0) {\r\n            animations.push([index, index, sortedColor, 'DONE_COMPARING']);\r\n        }\r\n\r\n        while (index >= 0 && unsortedElement < array[index]) {\r\n            array[index+1] = array[index];\r\n            // Changes color and values for bars as they shift\r\n            animations.push([index, array[index], index+1, array[index+1], compareColor, 'COMPARING']);\r\n            // Resets color of bars back to default now that swap is completed\r\n            animations.push([index, index+1, sortedColor, 'DONE_COMPARING']);\r\n            index -= 1;\r\n        }\r\n\r\n        // Makes sure index is colored sorted if it is smaller\r\n        // than unsortedElement\r\n        animations.push([index+1, index+1, sortedColor, 'DONE_COMPARING']);\r\n        \r\n        array[index+1] = unsortedElement;\r\n\r\n        // Changes the height of the last bar in iteration to reflect\r\n        // unsorted element being put in it's correct place\r\n        animations.push([index+1, array[index+1], 'SORTED']);\r\n    }\r\n\r\n    return animations;\r\n}\r\n\r\n\r\n\r\n// SHELL SORT\r\nexport const shellSort = (array) => { \r\n    let space = Math.floor(array.length/2);\r\n    const animations = [];\r\n    \r\n    while (space > 0) {\r\n\r\n        if (space % 2 === 0) { // Improves efficiency by assuring space is odd\r\n            space += 1;\r\n        }\r\n\r\n        for (let i=0; i < space; i++) {\r\n\r\n            // Changes color for all bars per index iteration within\r\n            // each space iteration\r\n            let barIndexArray = [];\r\n            for (let barIndex=i; barIndex < array.length; barIndex+=space) {\r\n                barIndexArray.push(barIndex);\r\n            }\r\n            animations.push([barIndexArray, secondCompareColor, 'COMPARING'])\r\n\r\n            const last = array.length-1;\r\n            for (let j = i+space; j <= last; j+=space) {\r\n                let unsortedElement = array[j];\r\n                let index = j-space;\r\n\r\n                while (index >= 0 && unsortedElement < array[index]) {\r\n                    array[index+space] = array[index];\r\n                    // Changes color and values for bars as they shift\r\n                    animations.push([index, array[index], index+space, array[index+space], compareColor, 'SHIFTING'])\r\n                    // Resets color of bars back to compareColor now that the swap is completed,\r\n                    // unless space=1, in which it is colored as completed\r\n                    if (space === 1) {\r\n                        animations.push([index, index+space, sortedColor, 'DONE_SHIFTING'])\r\n                    } else {\r\n                        animations.push([index, index+space, secondCompareColor, 'DONE_SHIFTING'])\r\n                    }\r\n                    index -= space;\r\n                }\r\n\r\n                array[index+space] = unsortedElement;\r\n                // Changes the height of the last bar in iteration to reflect\r\n                // unsorted element being put in it's correct place\r\n                animations.push([index+space, array[index+space], 'LAST_SHIFT'])\r\n                // Changes the color of the last bar to sorted when on the \r\n                // final pass\r\n                if (space === 1) {\r\n                    // Changes color to sorted if the first element is properly sorted\r\n                    // on the very last pass when space=1\r\n                    if (index === 0) {\r\n                        animations.push([index, sortedColor, 'SORTED'])\r\n                    }\r\n                    animations.push([index+space, sortedColor, 'SORTED'])\r\n                }\r\n            }\r\n            \r\n            // Resets each space iteration to default color unless it's\r\n            // the last iteration\r\n            if (space !== 1) {\r\n                animations.push([barIndexArray, defaultColor, 'DONE_COMPARING']);\r\n            }\r\n        }\r\n        space = Math.floor(space/2);\r\n    }\r\n    return animations;\r\n}\r\n\r\n\r\n\r\n// MERGE SORT\r\nexport const mergeSort = (array) => {\r\n    var auxArray = array.splice();\r\n    var animations = [];\r\n    mergeSortDivide(array, 0, array.length-1, auxArray, animations);\r\n    return animations;\r\n}\r\n\r\nconst mergeSortDivide = (array, startIndex, endIndex, auxArray, animations) => {\r\n    if (startIndex === endIndex) {\r\n        return;\r\n    }\r\n    var midIndex = Math.floor((startIndex + endIndex)/2);\r\n    mergeSortDivide(auxArray, startIndex, midIndex, array, animations);\r\n    mergeSortDivide(auxArray, midIndex+1, endIndex, array, animations);\r\n\r\n    return mergeSortMerge(array, startIndex, midIndex, endIndex, auxArray, animations);\r\n}\r\n\r\nconst mergeSortMerge = (array, startIndex, midIndex, endIndex, auxArray, animations) => {\r\n    let i = startIndex;\r\n    let j = midIndex;\r\n    let k = endIndex;\r\n    animations.push([startIndex, endIndex, secondCompareColor, 'GROUPING_ARRAY'])\r\n    \r\n    while (i <= midIndex && j <= endIndex) {\r\n        animations.push([i, j, compareColor, 'COMPARING']);\r\n        \r\n        if (auxArray[i] <= auxArray[j]) {\r\n            array[k] = array[i];\r\n            animations.push([k, array[i], 'CHANGING_VALUE']);\r\n            animations.push([i, j, secondCompareColor, 'DONE_COMPARING']);\r\n            i++;\r\n        } else {\r\n            // Assertion: auxArray[i] > auxArray[j]\r\n            array[k] = array[j];\r\n            animations.push([k, array[j], 'CHANGING_VALUE']);\r\n            animations.push([i, j, secondCompareColor, 'DONE_COMPARING']);\r\n            j++;\r\n        }\r\n    }\r\n    // while (i <= midIndex) {\r\n    //     animations.push([i, j, compareColor, 'COMPARING']);\r\n    //     array[k] = array[i];\r\n    //     animations.push([k, array[i], 'CHANGING_VALUE']);\r\n    //     animations.push([i, j, secondCompareColor, 'DONE_COMPARING']);\r\n    //     i++;\r\n    // }\r\n    // while (j <= endIndex) {\r\n    //     animations.push([i, j, compareColor, 'COMPARING']);\r\n    //     array[k] = array[j];\r\n    //     animations.push([k, array[j], 'CHANGING_VALUE']);\r\n    //     animations.push([i, j, secondCompareColor, 'DONE_COMPARING']);\r\n    //     j++;\r\n    // }\r\n\r\n\r\n\r\n    \r\n    // while (i <= midIndex && j <= endIndex) {\r\n    //     // These are the values that we're comparing; we push them once\r\n    //     // to change their color.\r\n    //     animations.push([i, j, compareColor, 'COMPARING']);\r\n    //     // These are the values that we're comparing; we push them a second\r\n    //     // time to revert their color.\r\n    //     animations.push([i, j, compareColor, 'DONE_COMPARING']);\r\n    //     if (auxArray[i] <= auxArray[j]) {\r\n    //       // We overwrite the value at index k in the original array with the\r\n    //       // value at index i in the auxiliary array.\r\n    //       animations.push([k, auxArray[i], 'CHANGING_VALUE']);\r\n    //       array[k++] = auxArray[i++];\r\n    //     } else {\r\n    //       // We overwrite the value at index k in the original array with the\r\n    //       // value at index j in the auxiliary array.\r\n    //       animations.push([k, auxArray[j], 'CHANGING_VALUE']);\r\n    //       array[k++] = auxArray[j++];\r\n    //     }\r\n    // }\r\n    // while (i <= midIndex) {\r\n    //     // These are the values that we're comparing; we push them once\r\n    //     // to change their color.\r\n    //     animations.push([i, i, compareColor, 'COMPARING']);\r\n    //     // These are the values that we're comparing; we push them a second\r\n    //     // time to revert their color.\r\n    //     animations.push([i, i, compareColor, 'DONE_COMPARING']);\r\n    //     // We overwrite the value at index k in the original array with the\r\n    //     // value at index i in the auxiliary array.\r\n    //     animations.push([k, auxArray[i], 'CHANGING_VALUE']);\r\n    //     array[k++] = auxArray[i++];\r\n    //   }\r\n    //   while (j <= endIndex) {\r\n    //     // These are the values that we're comparing; we push them once\r\n    //     // to change their color.\r\n    //     animations.push([j, j, compareColor, 'COMPARING']);\r\n    //     // These are the values that we're comparing; we push them a second\r\n    //     // time to revert their color.\r\n    //     animations.push([j, j, compareColor, 'DONE_COMPARING']);\r\n    //     // We overwrite the value at index k in the original array with the\r\n    //     // value at index j in the auxiliary array.\r\n    //     animations.push([k, auxArray[j], 'CHANGING_VALUE']);\r\n    //     array[k++] = auxArray[j++];\r\n    //   }\r\n\r\n    animations.push([startIndex, endIndex, defaultColor, 'DONE_GROUPING_ARRAY']);\r\n}","import React from 'react';\r\nimport * as sortingAlgorithms from './sortingAlgorithms.js';\r\nimport './SortingVisualizer.css';\r\nimport Button from 'react-bootstrap/Button';\r\n\r\n// Controls the speed of the animations\r\nconst SPEED_MS = 75;\r\nconst DEFAULT_COLOR = '#7f78d2';\r\nvar sortIsRunning = false;\r\n\r\nexport default class SortingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n\r\n        this.state = {\r\n            array: []\r\n        };\r\n    }\r\n\r\n    // When app loads for the first time\r\n    componentDidMount() {\r\n        this.resetArray();\r\n    }\r\n\r\n    resetArray() {\r\n        const array = [];\r\n        for (let i=0; i < 100; i++) {\r\n            array.push(getRandomInt(5, 600));\r\n            // array.push(i+1)\r\n        }\r\n        this.setState({array});\r\n        resetColors();\r\n        sortIsRunning = false;\r\n    }   \r\n\r\n    compareSorts(array1, array2) {\r\n        if (array1.length !== array2.length) {\r\n            return false\r\n        }\r\n        for (let i=0; i < array1.length; i++) {\r\n            if (array1[i] !== array2[i]) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n    printArrays(array1, array2) {\r\n        console.log(\"State: \" + array1.toString())\r\n        console.log(\"Sorted: \" + array2.toString())\r\n    }\r\n\r\n    render() {\r\n        const {array} = this.state;\r\n\r\n        return (\r\n            <div className=\"app-container\" class=\"app-container d-flex-row\">\r\n                    <div className=\"array-bar-container\" class=\"array-bar-container d-flex-row justify-content-center d-flex align-items-end\">\r\n                        {array.map((element, index) => (\r\n                            <div className=\"array-bar\" id={`bar-${element}`} key={index} \r\n                                style={{height: `${element}px`, backgroundColor: `${DEFAULT_COLOR}`}}>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                <div className=\"buttons-container\" class=\"buttons-container justify-content-center\">\r\n                    <Button size=\"lg\" variant=\"primary\" onClick={() => this.resetArray()}>Generate New Array</Button>\r\n                    <Button size=\"lg\" class=\"sortButton\" variant=\"outline-success\" onClick={() => this.selectionSort()}>Selection Sort</Button>\r\n                    <Button size=\"lg\" class=\"sortButton\" variant=\"outline-success\" onClick={() => this.insertionSort()}>Insertion Sort</Button>\r\n                    <Button size=\"lg\" class=\"sortButton\" variant=\"outline-success\" onClick={() => this.shellSort()}>Shell Sort</Button>\r\n                    {/* <Button size=\"lg\" class=\"sortButton\" variant=\"outline-success\" onClick={() => this.mergeSort()}>Merge Sort</Button> */}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    // SORTING ALGORITHMS\r\n\r\n    selectionSort() {\r\n        // this.changeButtonState();\r\n        while (sortIsRunning === false) {\r\n            sortIsRunning = true;\r\n            let animations = sortingAlgorithms.selectionSort(this.state.array);\r\n            const selectionSortSpeed = SPEED_MS/2;\r\n\r\n            for (let i=0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                const animationType = animations[i][animations[i].length-1];\r\n            \r\n                if (animationType === 'COMPARING') {\r\n                    // For turning on color for bars to be compared\r\n                    const [barOneIndex, barTwoIndex, color] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIndex].style;\r\n                    const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    }, i*selectionSortSpeed);\r\n                } else if (animationType === 'SWAP_VALUES') {\r\n                    // For swapping height (values) of bars\r\n                    setTimeout(() => {\r\n                        const [barOneIndex, barOneValue, barTwoIndex, barTwoValue] = animations[i];\r\n                        const barOneStyle = arrayBars[barOneIndex].style;\r\n                        const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                        barOneStyle.height = `${barTwoValue}px`;\r\n                        barTwoStyle.height = `${barOneValue}px`;\r\n                    }, i*selectionSortSpeed);\r\n                } else { // Assertion: animationType === 'SORTED'\r\n                    // For resetting bars back to default/sorted color\r\n                    const [sortedBarIndex, otherBarIndex, defaultColor, sortedColor] = animations[i];\r\n                    const sortedBarStyle = arrayBars[sortedBarIndex].style;\r\n                    const otherBarStyle = arrayBars[otherBarIndex].style;    \r\n                    setTimeout(() => {\r\n                        otherBarStyle.backgroundColor = defaultColor;\r\n                        sortedBarStyle.backgroundColor = sortedColor;\r\n                    }, i*selectionSortSpeed);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    insertionSort() {\r\n        while (sortIsRunning === false) {\r\n            sortIsRunning = true;\r\n            let animations = sortingAlgorithms.insertionSort(this.state.array);\r\n            const insertionSortSpeed = SPEED_MS/20;\r\n\r\n            for (let i=0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                const animationType = animations[i][animations[i].length-1];\r\n\r\n                if (animationType === 'COMPARING') {\r\n                    // Changes color and values for bars as they shift\r\n                    const [barOneIndex, barOneValue, barTwoIndex, barTwoValue, color] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIndex].style;\r\n                    const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barOneStyle.height = `${barTwoValue}px`;\r\n                        barTwoStyle.backgroundColor = color;\r\n                        barTwoStyle.height = `${barOneValue}px`;\r\n                    }, (i-1)*insertionSortSpeed); // Prevents flashing affect in visual by removing delay\r\n                } else if (animationType === 'DONE_COMPARING') {\r\n                    // Resets color of bars back to default now that swap is completed\r\n                    const [barOneIndex, barTwoIndex, color] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIndex].style;\r\n                    const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    }, i*insertionSortSpeed);\r\n                } else { // Assertion: animationType === 'SORTED'\r\n                    // Changes the height of the last bar in iteration to reflect\r\n                    // unsorted element being put in it's correct place\r\n                    const [finalBarIndex, finalBarValue] = animations[i];\r\n                    const finalBarStyle = arrayBars[finalBarIndex].style;\r\n                    setTimeout(() => {\r\n                        finalBarStyle.height = `${finalBarValue}px`;\r\n                    }, i*insertionSortSpeed);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    shellSort() {\r\n        while (sortIsRunning === false) {\r\n            sortIsRunning = true;\r\n            let animations = sortingAlgorithms.shellSort(this.state.array);\r\n            const shellSortSpeed = SPEED_MS/6;\r\n\r\n            for (let i=0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                const animationType = animations[i][animations[i].length-1];\r\n\r\n                if (animationType === 'COMPARING') {\r\n                    // Changes color for all bars in the grouping for index iteration\r\n                    // per each space iteration\r\n                    const [barIndexArray, color] = animations[i];\r\n                    setTimeout(() => {\r\n                        for (let bar=0; bar < barIndexArray.length; bar++) {\r\n                            const barIndex = barIndexArray[bar];\r\n                            const barStyle = arrayBars[barIndex].style;\r\n                            barStyle.backgroundColor = color;\r\n                        }\r\n                    }, (i-1)*shellSortSpeed); // Prevents flashing affect in visual by removing delay\r\n                } else if (animationType === 'SHIFTING') {\r\n                    // Changes color and values for bars as they shift\r\n                    const [barOneIndex, barOneValue, barTwoIndex, barTwoValue, color] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIndex].style;\r\n                    const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barOneStyle.height = `${barTwoValue}px`;\r\n                        barTwoStyle.backgroundColor = color;\r\n                        barTwoStyle.height = `${barOneValue}px`;\r\n                    }, (i-1)*shellSortSpeed); // Prevents flashing affect in visual by removing delay\r\n                } else if (animationType === 'DONE_SHIFTING') {\r\n                    // Resets color of bars back to compareColor now that the swap \r\n                    // is completed\r\n                    const [barOneIndex, barTwoIndex, color] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIndex].style;\r\n                    const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    }, i*shellSortSpeed);\r\n                } else if (animationType === 'LAST_SHIFT') {\r\n                    // Changes the height of the last bar in iteration to reflect\r\n                    // unsorted element being put in it's correct place\r\n                    const [finalBarIndex, finalBarValue] = animations[i];\r\n                    const finalBarStyle = arrayBars[finalBarIndex].style;\r\n                    setTimeout(() => {\r\n                        finalBarStyle.height = `${finalBarValue}px`;\r\n                    }, i*shellSortSpeed);\r\n                } else if (animationType === 'SORTED') {\r\n                    // Changes the color of bars to sorted when on the final pass\r\n                    const [finalBarIndex, color] = animations[i];\r\n                    const finalBarStyle = arrayBars[finalBarIndex].style;\r\n                    setTimeout(() => {\r\n                        finalBarStyle.backgroundColor = color;\r\n                    }, i*shellSortSpeed);\r\n                } else { // Assertion: animationType === 'DONE_COMPARING'\r\n                    // Resets color for all bars in the grouping for index iteration\r\n                    // per each space iteration\r\n                    const [barIndexArray, color] = animations[i];\r\n                    setTimeout(() => {\r\n                        for (let bar=0; bar < barIndexArray.length; bar++) {\r\n                            const barIndex = barIndexArray[bar];\r\n                            const barStyle = arrayBars[barIndex].style;\r\n                            barStyle.backgroundColor = color;\r\n                        }\r\n                    }, i*shellSortSpeed);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    mergeSort() {\r\n        while (sortIsRunning === false) {\r\n            sortIsRunning = true;\r\n            let animations = sortingAlgorithms.mergeSort(this.state.array);\r\n            const mergeSortSpeed = SPEED_MS/6;\r\n\r\n            for (let i=0; i < animations.length; i++) {\r\n                const arrayBars = document.getElementsByClassName('array-bar');\r\n                const animationType = animations[i][animations[i].length-1];\r\n\r\n                if (animationType === 'GROUPING_ARRAY') {\r\n                    const [start, end, color] = animations[i];\r\n                    setTimeout(() => {\r\n                        for (let bar=start; bar < end; bar++) {\r\n                            const barStyle = arrayBars[bar].style;\r\n                            barStyle.backgroundColor = color;\r\n                        }\r\n                    }, (i-1)*mergeSortSpeed);\r\n                } else if (animationType === 'COMPARING') {\r\n                    const [barOneIndex, barTwoIndex, color] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIndex].style;\r\n                    const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    }, (i-1)*mergeSortSpeed);\r\n                } else if (animationType === 'CHANGING VALUE') {\r\n                    const [barIndex, barValue] = animations[i];\r\n                    const barStyle = arrayBars[barIndex].style;\r\n                    setTimeout(() => {\r\n                        barStyle.height = `${barValue}px`;\r\n                    }, i*mergeSortSpeed);\r\n                } else if (animationType === 'DONE_COMPARING') {\r\n                    const [barOneIndex, barTwoIndex, color] = animations[i];\r\n                    const barOneStyle = arrayBars[barOneIndex].style;\r\n                    const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                    setTimeout(() => {\r\n                        barOneStyle.backgroundColor = color;\r\n                        barTwoStyle.backgroundColor = color;\r\n                    }, i*mergeSortSpeed);\r\n                } else if (animationType === 'DONE_GROUPING') {\r\n                    const [start, end, color] = animations[i];\r\n                    setTimeout(() => {\r\n                        for (let bar=start; bar < end; bar++) {\r\n                            const barStyle = arrayBars[bar].style;\r\n                            barStyle.backgroundColor = color;\r\n                        }\r\n                    }, i*mergeSortSpeed);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    quickSort() {}\r\n}\r\n\r\n\r\n// From https://www.w3schools.com/js/js_random.asp\r\n// Min and Max are both inclusive.\r\nfunction getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) ) + min;\r\n}\r\n\r\n// Resets bar colors to default\r\nfunction resetColors() {\r\n    const arrayBars = document.getElementsByClassName('array-bar');\r\n    for (let i=0; i < arrayBars.length; i++) {\r\n        const barStyle = arrayBars[i].style;\r\n        barStyle.backgroundColor = DEFAULT_COLOR;\r\n    }\r\n}","import React from 'react';\nimport './App.css';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}